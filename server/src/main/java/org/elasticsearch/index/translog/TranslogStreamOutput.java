/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

package org.elasticsearch.index.translog;

import org.apache.lucene.util.BytesRef;
import org.apache.lucene.util.BytesRefIterator;
import org.elasticsearch.common.io.stream.RecyclerBytesStreamOutput;
import org.elasticsearch.common.recycler.Recycler;

import java.io.IOException;

/**
 * This class provided specialized serialization methods for translog operations. The goal is to allow direct
 * access to the current recycler bytes stream output page and write the entire operation with a single bounds
 * check.
 */
public class TranslogStreamOutput extends RecyclerBytesStreamOutput {

    public static final int FIXED_INDEX_HEADER_SIZE = 39;
    public static final int FIXED_DELETE_HEADER_SIZE = 30;
    public static final int FIXED_NO_OP_HEADER_SIZE = 21;

    public TranslogStreamOutput(Recycler<BytesRef> recycler) {
        super(recycler);
    }

    public void writeSerializedOperation(Translog.Serialized serialized) throws IOException {
        final int preWritePageOffset = this.currentPageOffset;
        final BytesRefIterator refIterator = serialized.iterator();
        if (serialized.length() <= (pageSize - preWritePageOffset)) {
            BytesRef currentPage = currentBytesRef;
            int offset = currentPage.offset + preWritePageOffset;
            byte[] pageBytes = currentPage.bytes;
            BytesRef ref;
            while ((ref = refIterator.next()) != null) {
                System.arraycopy(ref.bytes, ref.offset, pageBytes, offset, ref.length);
                offset += ref.length;
            }
            VH_BE_INT.set(pageBytes, offset, serialized.checksum());
            this.currentPageOffset = preWritePageOffset + serialized.length();
        } else {
            BytesRef next;
            while ((next = refIterator.next()) != null) {
                writeBytes(next.bytes, next.offset, next.length);
            }
            writeInt(serialized.checksum());
        }
    }

    public void writeIndexHeader(Translog.Index indexOperation) throws IOException {
        final int currentPageOffset = this.currentPageOffset;
        if (FIXED_INDEX_HEADER_SIZE <= (pageSize - currentPageOffset)) {
            String routing = indexOperation.routing();

            BytesRef currentPage = pages.get(this.pageIndex).v();
            int off = currentPage.offset + currentPageOffset;
            byte[] localBytesRef = currentPage.bytes;
            localBytesRef[off + 4] = Translog.Operation.Type.INDEX.id();
            // This is technically a vInt in the serialization, but until we advance past 127 we can just directly serialize as a byte
            localBytesRef[off + 5] = (byte) Translog.Index.SERIALIZATION_FORMAT;
            VH_BE_LONG.set(localBytesRef, off + 6, indexOperation.version());
            VH_BE_LONG.set(localBytesRef, off + 14, indexOperation.getAutoGeneratedIdTimestamp());
            VH_BE_LONG.set(localBytesRef, off + 22, indexOperation.seqNo());
            VH_BE_LONG.set(localBytesRef, off + 30, indexOperation.primaryTerm());
            localBytesRef[off + 38] = indexOperation.routing() == null ? (byte) 0 : (byte) 1;
            this.currentPageOffset = currentPageOffset + FIXED_INDEX_HEADER_SIZE;

            long variableLengthStart = position();
            // Write variable length items in header
            if (routing != null) {
                writeString(routing);
            }
            writeString(indexOperation.id());

            int sourceLength = indexOperation.source().length();
            writeVInt(indexOperation.source().length());

            int variableLengthSize = (int) (position() - variableLengthStart);
            int sizeOfOperation = FIXED_INDEX_HEADER_SIZE - Integer.BYTES + variableLengthSize + sourceLength + Integer.BYTES;
            VH_BE_INT.set(localBytesRef, off, sizeOfOperation);
        } else {
            writeSlowFixedIndexHeader(indexOperation);
        }
    }

    private void writeSlowFixedIndexHeader(Translog.Index indexOperation) throws IOException {
        final long start = position();
        skip(Integer.BYTES);
        writeByte(Translog.Operation.Type.INDEX.id());
        writeVInt(Translog.Index.SERIALIZATION_FORMAT);
        writeLong(indexOperation.version());
        writeLong(indexOperation.getAutoGeneratedIdTimestamp());
        writeLong(indexOperation.seqNo());
        writeLong(indexOperation.primaryTerm());
        writeOptionalString(indexOperation.routing());
        writeString(indexOperation.id());
        final long end = position();
        // The total operation size is the header size + source size + 4 bytes for checksum
        final int operationSize = (int) (end - Integer.BYTES - start) + indexOperation.source().length() + Integer.BYTES;
        seek(start);
        writeInt(operationSize);
        seek(end);
    }

    public void writeDeleteHeader(Translog.Delete delete) throws IOException {
        final int currentPageOffset = this.currentPageOffset;
        if (FIXED_DELETE_HEADER_SIZE <= (pageSize - currentPageOffset)) {
            BytesRef currentPage = pages.get(this.pageIndex).v();
            int off = currentPage.offset + currentPageOffset;
            byte[] localBytesRef = currentPage.bytes;
            localBytesRef[off + 4] = Translog.Operation.Type.DELETE.id();
            // This is technically a vInt in the serialization, but until we advance past 127 we can just directly serialize as a byte
            localBytesRef[off + 5] = (byte) Translog.Delete.SERIALIZATION_FORMAT;
            VH_BE_LONG.set(localBytesRef, off + 6, delete.version());
            VH_BE_LONG.set(localBytesRef, off + 14, delete.seqNo());
            VH_BE_LONG.set(localBytesRef, off + 22, delete.primaryTerm());
            this.currentPageOffset = currentPageOffset + FIXED_DELETE_HEADER_SIZE;

            long variableLengthStart = position();
            // Write variable length items in header
            writeString(delete.id());
            int variableLengthSize = (int) (position() - variableLengthStart);
            // The total operation size is the header size + 4 bytes for checksum
            int sizeOfOperation = FIXED_DELETE_HEADER_SIZE - Integer.BYTES + variableLengthSize + Integer.BYTES;
            VH_BE_INT.set(localBytesRef, off, sizeOfOperation);
        } else {
            writeSlowDeleteHeader(delete);
        }
    }

    private void writeSlowDeleteHeader(Translog.Delete delete) throws IOException {
        final long start = position();
        skip(Integer.BYTES);
        writeByte(Translog.Operation.Type.DELETE.id());
        writeVInt(Translog.Delete.SERIALIZATION_FORMAT);
        writeLong(delete.version());
        writeLong(delete.seqNo());
        writeLong(delete.primaryTerm());
        final long end = position();
        // The total operation size is the header size + 4 bytes for checksum
        final int operationSize = (int) (end - Integer.BYTES - start) + Integer.BYTES;
        seek(start);
        writeInt(operationSize);
        seek(end);
    }

    public void writeNoOpHeader(Translog.NoOp noop) throws IOException {
        final int currentPageOffset = this.currentPageOffset;
        if (FIXED_NO_OP_HEADER_SIZE <= (pageSize - currentPageOffset)) {
            BytesRef currentPage = pages.get(this.pageIndex).v();
            int off = currentPage.offset + currentPageOffset;
            byte[] localBytesRef = currentPage.bytes;
            localBytesRef[off + 4] = Translog.Operation.Type.NO_OP.id();
            VH_BE_LONG.set(localBytesRef, off + 5, noop.seqNo());
            VH_BE_LONG.set(localBytesRef, off + 13, noop.primaryTerm());
            this.currentPageOffset = currentPageOffset + FIXED_NO_OP_HEADER_SIZE;

            long variableLengthStart = position();
            // Write variable length items in header
            writeString(noop.reason());
            int variableLengthSize = (int) (position() - variableLengthStart);
            // The total operation size is the header size + 4 bytes for checksum
            int sizeOfOperation = FIXED_NO_OP_HEADER_SIZE - Integer.BYTES + variableLengthSize + Integer.BYTES;
            VH_BE_INT.set(localBytesRef, off, sizeOfOperation);
        } else {
            writeSlowNoOpHeader(noop);
        }
    }

    private void writeSlowNoOpHeader(Translog.NoOp noop) throws IOException {
        final long start = position();
        skip(Integer.BYTES);
        writeByte(Translog.Operation.Type.NO_OP.id());
        writeLong(noop.seqNo());
        writeLong(noop.primaryTerm());
        writeString(noop.reason());
        final long end = position();
        // The total operation size is the header size + 4 bytes for checksum
        final int operationSize = (int) (end - Integer.BYTES - start) + Integer.BYTES;
        seek(start);
        writeInt(operationSize);
        seek(end);
    }
}
