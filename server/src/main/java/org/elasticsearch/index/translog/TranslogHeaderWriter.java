/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

package org.elasticsearch.index.translog;

import org.apache.lucene.util.BytesRef;
import org.elasticsearch.common.io.stream.RecyclerBytesStreamOutput;
import org.elasticsearch.common.util.ByteUtils;

import java.io.IOException;

/**
 * This class provided specialized serialization methods for translog operations. The goal is to allow direct
 * access to the current recycler bytes stream output page and write the entire operation with a single bounds
 * check.
 */
public final class TranslogHeaderWriter {

    public static final int FIXED_INDEX_HEADER_SIZE = 39;
    public static final int FIXED_DELETE_HEADER_SIZE = 30;
    public static final int FIXED_NO_OP_HEADER_SIZE = 21;

    private TranslogHeaderWriter() {}

    public static void writeIndexHeader(RecyclerBytesStreamOutput buffer, Translog.Index indexOperation) throws IOException {
        BytesRef bytesRef = buffer.tryGetPageForWrite(FIXED_INDEX_HEADER_SIZE);
        if (bytesRef != null) {
            String routing = indexOperation.routing();

            int off = bytesRef.offset;
            byte[] bytes = bytesRef.bytes;
            bytes[off + 4] = Translog.Operation.Type.INDEX.id();
            // This is technically a vInt in the serialization, but until we advance past 127 we can just directly serialize as a byte
            bytes[off + 5] = (byte) Translog.Index.SERIALIZATION_FORMAT;
            ByteUtils.writeLongBE(indexOperation.version(), bytes, off + 6);
            ByteUtils.writeLongBE(indexOperation.getAutoGeneratedIdTimestamp(), bytes, off + 14);
            ByteUtils.writeLongBE(indexOperation.seqNo(), bytes, off + 22);
            ByteUtils.writeLongBE(indexOperation.primaryTerm(), bytes, off + 30);
            bytes[off + 38] = indexOperation.routing() == null ? (byte) 0 : (byte) 1;

            long variableLengthStart = buffer.position();
            // Write variable length items in header
            if (routing != null) {
                buffer.writeString(routing);
            }
            buffer.writeString(indexOperation.id());

            int sourceLength = indexOperation.source().length();
            buffer.writeVInt(indexOperation.source().length());

            int variableLengthSize = (int) (buffer.position() - variableLengthStart);
            int sizeOfOperation = FIXED_INDEX_HEADER_SIZE - Integer.BYTES + variableLengthSize + sourceLength + Integer.BYTES;
            ByteUtils.writeIntBE(sizeOfOperation, bytes, off);
        } else {
            writeSlowFixedIndexHeader(buffer, indexOperation);
        }
    }

    private static void writeSlowFixedIndexHeader(RecyclerBytesStreamOutput buffer, Translog.Index indexOperation) throws IOException {
        final long start = buffer.position();
        buffer.skip(Integer.BYTES);
        buffer.writeByte(Translog.Operation.Type.INDEX.id());
        buffer.writeVInt(Translog.Index.SERIALIZATION_FORMAT);
        buffer.writeLong(indexOperation.version());
        buffer.writeLong(indexOperation.getAutoGeneratedIdTimestamp());
        buffer.writeLong(indexOperation.seqNo());
        buffer.writeLong(indexOperation.primaryTerm());
        buffer.writeOptionalString(indexOperation.routing());
        buffer.writeString(indexOperation.id());
        buffer.writeVInt(indexOperation.source().length());
        final long end = buffer.position();
        // The total operation size is the header size + source size + 4 bytes for checksum
        final int operationSize = (int) (end - Integer.BYTES - start) + indexOperation.source().length() + Integer.BYTES;
        buffer.seek(start);
        buffer.writeInt(operationSize);
        buffer.seek(end);
    }

    public static void writeDeleteHeader(RecyclerBytesStreamOutput buffer, Translog.Delete delete) throws IOException {
        BytesRef bytesRef = buffer.tryGetPageForWrite(FIXED_DELETE_HEADER_SIZE);
        if (bytesRef != null) {
            int off = bytesRef.offset;
            byte[] bytes = bytesRef.bytes;
            bytes[off + 4] = Translog.Operation.Type.DELETE.id();
            // This is technically a vInt in the serialization, but until we advance past 127 we can just directly serialize as a byte
            bytes[off + 5] = (byte) Translog.Delete.SERIALIZATION_FORMAT;
            ByteUtils.writeLongBE(delete.version(), bytes, off + 6);
            ByteUtils.writeLongBE(delete.seqNo(), bytes, off + 14);
            ByteUtils.writeLongBE(delete.primaryTerm(), bytes, off + 22);

            long variableLengthStart = buffer.position();
            // Write variable length items in header
            buffer.writeString(delete.id());
            int variableLengthSize = (int) (buffer.position() - variableLengthStart);
            // The total operation size is the header size + 4 bytes for checksum
            int sizeOfOperation = FIXED_DELETE_HEADER_SIZE - Integer.BYTES + variableLengthSize + Integer.BYTES;
            ByteUtils.writeIntBE(sizeOfOperation, bytes, off);
        } else {
            writeSlowDeleteHeader(buffer, delete);
        }
    }

    private static void writeSlowDeleteHeader(RecyclerBytesStreamOutput buffer, Translog.Delete delete) throws IOException {
        final long start = buffer.position();
        buffer.skip(Integer.BYTES);
        buffer.writeByte(Translog.Operation.Type.DELETE.id());
        buffer.writeVInt(Translog.Delete.SERIALIZATION_FORMAT);
        buffer.writeLong(delete.version());
        buffer.writeLong(delete.seqNo());
        buffer.writeLong(delete.primaryTerm());
        buffer.writeString(delete.id());
        final long end = buffer.position();
        // The total operation size is the header size + 4 bytes for checksum
        final int operationSize = (int) (end - Integer.BYTES - start) + Integer.BYTES;
        buffer.seek(start);
        buffer.writeInt(operationSize);
        buffer.seek(end);
    }

    public static void writeNoOpHeader(RecyclerBytesStreamOutput buffer, Translog.NoOp noop) throws IOException {
        BytesRef bytesRef = buffer.tryGetPageForWrite(FIXED_NO_OP_HEADER_SIZE);
        if (bytesRef != null) {
            int off = bytesRef.offset;
            byte[] bytes = bytesRef.bytes;
            bytes[off + 4] = Translog.Operation.Type.NO_OP.id();
            ByteUtils.writeLongBE(noop.seqNo(), bytes, off + 5);
            ByteUtils.writeLongBE(noop.primaryTerm(), bytes, off + 13);

            long variableLengthStart = buffer.position();
            // Write variable length items in header
            buffer.writeString(noop.reason());
            int variableLengthSize = (int) (buffer.position() - variableLengthStart);
            // The total operation size is the header size + 4 bytes for checksum
            int sizeOfOperation = FIXED_NO_OP_HEADER_SIZE - Integer.BYTES + variableLengthSize + Integer.BYTES;
            ByteUtils.writeIntBE(sizeOfOperation, bytes, off);
        } else {
            writeSlowNoOpHeader(buffer, noop);
        }
    }

    private static void writeSlowNoOpHeader(RecyclerBytesStreamOutput buffer, Translog.NoOp noop) throws IOException {
        final long start = buffer.position();
        buffer.skip(Integer.BYTES);
        buffer.writeByte(Translog.Operation.Type.NO_OP.id());
        buffer.writeLong(noop.seqNo());
        buffer.writeLong(noop.primaryTerm());
        buffer.writeString(noop.reason());
        final long end = buffer.position();
        // The total operation size is the header size + 4 bytes for checksum
        final int operationSize = (int) (end - Integer.BYTES - start) + Integer.BYTES;
        buffer.seek(start);
        buffer.writeInt(operationSize);
        buffer.seek(end);
    }
}
