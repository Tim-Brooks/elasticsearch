/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

package org.elasticsearch.index.translog;

import org.elasticsearch.common.bytes.BytesArray;
import org.elasticsearch.common.bytes.BytesReference;
import org.elasticsearch.common.io.stream.BytesStreamOutput;
import org.elasticsearch.test.ESTestCase;
import org.elasticsearch.transport.BytesRefRecycler;

import java.io.IOException;
import java.util.zip.CRC32;

import static org.hamcrest.Matchers.equalTo;

/**
 * Tests to ensure that the multistep optimized TranslogStreamOutput serialization matches the standard
 * StreamOutput version.
 */
public class TranslogStreamOutputTests extends ESTestCase {

    public void testIndexOperationSerializationMatches() throws IOException {
        TranslogStreamOutput headerOutput = new TranslogStreamOutput(BytesRefRecycler.NON_RECYCLING_INSTANCE);
        TranslogStreamOutput fullOperationOutput = new TranslogStreamOutput(BytesRefRecycler.NON_RECYCLING_INSTANCE);

        for (int i = 0; i < 30; i++) {
            // Test both the fast path (single page) and slow page (cross page)
            int offset;
            if (randomBoolean()) {
                offset = 0;
            } else {
                offset = BytesRefRecycler.NON_RECYCLING_INSTANCE.pageSize() - 1;
            }
            headerOutput.seek(offset);
            fullOperationOutput.seek(offset);

            String id = randomAlphaOfLength(20);
            long seqNo = randomLongBetween(0, Long.MAX_VALUE);
            long primaryTerm = randomLongBetween(0, Long.MAX_VALUE);
            long version = randomLongBetween(0, Long.MAX_VALUE);
            String routing = randomAlphaOfLength(20);
            BytesArray source = new BytesArray(randomByteArrayOfLength(randomIntBetween(50, 4196)));
            long autoGeneratedIdTimestamp = randomLongBetween(0, Long.MAX_VALUE);
            Translog.Index index = new Translog.Index(id, seqNo, primaryTerm, version, source, routing, autoGeneratedIdTimestamp);

            BytesStreamOutput bytesStreamOutput = new BytesStreamOutput();
            BufferedChecksumStreamOutput output = new BufferedChecksumStreamOutput(bytesStreamOutput);
            Translog.writeOperationNoSize(output, index);
            BytesReference expectedWithoutSize = bytesStreamOutput.bytes();

            headerOutput.writeIndexHeader(index);
            BytesReference headerBytes = headerOutput.bytes();
            Translog.Serialized serialized = Translog.Serialized.create(
                headerBytes.slice(offset, headerBytes.length() - offset),
                source,
                new CRC32()
            );
            serialized.writeToTranslogBuffer(fullOperationOutput);

            BytesReference actualWithSize = fullOperationOutput.bytes();
            assertThat(actualWithSize.slice(4 + offset, actualWithSize.length() - offset - 4), equalTo(expectedWithoutSize));
        }

    }

    public void testDeleteOperationSerializationMatches() throws IOException {
        TranslogStreamOutput headerOutput = new TranslogStreamOutput(BytesRefRecycler.NON_RECYCLING_INSTANCE);
        TranslogStreamOutput fullOperationOutput = new TranslogStreamOutput(BytesRefRecycler.NON_RECYCLING_INSTANCE);

        for (int i = 0; i < 30; i++) {
            // Test both the fast path (single page) and slow page (cross page)
            int offset;
            if (randomBoolean()) {
                offset = 0;
            } else {
                offset = BytesRefRecycler.NON_RECYCLING_INSTANCE.pageSize() - 1;
            }
            headerOutput.seek(offset);
            fullOperationOutput.seek(offset);

            String id = randomAlphaOfLength(20);
            long seqNo = randomLongBetween(0, Long.MAX_VALUE);
            long primaryTerm = randomLongBetween(0, Long.MAX_VALUE);
            long version = randomLongBetween(0, Long.MAX_VALUE);
            Translog.Delete delete = new Translog.Delete(id, seqNo, primaryTerm, version);

            BytesStreamOutput bytesStreamOutput = new BytesStreamOutput();
            BufferedChecksumStreamOutput output = new BufferedChecksumStreamOutput(bytesStreamOutput);
            Translog.writeOperationNoSize(output, delete);
            BytesReference expectedWithoutSize = bytesStreamOutput.bytes();

            headerOutput.writeDeleteHeader(delete);
            BytesReference headerBytes = headerOutput.bytes();
            Translog.Serialized serialized = Translog.Serialized.create(
                headerBytes.slice(offset, headerBytes.length() - offset),
                null,
                new CRC32()
            );
            serialized.writeToTranslogBuffer(fullOperationOutput);

            BytesReference actualWithSize = fullOperationOutput.bytes();
            assertThat(actualWithSize.slice(4 + offset, actualWithSize.length() - offset - 4), equalTo(expectedWithoutSize));
        }
    }

    public void testNoOpOperationSerializationMatches() throws IOException {
        TranslogStreamOutput headerOutput = new TranslogStreamOutput(BytesRefRecycler.NON_RECYCLING_INSTANCE);
        TranslogStreamOutput fullOperationOutput = new TranslogStreamOutput(BytesRefRecycler.NON_RECYCLING_INSTANCE);

        for (int i = 0; i < 30; i++) {
            // Test both the fast path (single page) and slow page (cross page)
            int offset;
            if (randomBoolean()) {
                offset = 0;
            } else {
                offset = BytesRefRecycler.NON_RECYCLING_INSTANCE.pageSize() - 1;
            }
            headerOutput.seek(offset);
            fullOperationOutput.seek(offset);

            long seqNo = randomLongBetween(0, Long.MAX_VALUE);
            long primaryTerm = randomLongBetween(0, Long.MAX_VALUE);
            String reason = randomAlphaOfLength(20);
            Translog.NoOp noOp = new Translog.NoOp(seqNo, primaryTerm, reason);

            BytesStreamOutput bytesStreamOutput = new BytesStreamOutput();
            BufferedChecksumStreamOutput output = new BufferedChecksumStreamOutput(bytesStreamOutput);
            Translog.writeOperationNoSize(output, noOp);
            BytesReference expectedWithoutSize = bytesStreamOutput.bytes();

            headerOutput.writeNoOpHeader(noOp);
            BytesReference headerBytes = headerOutput.bytes();
            Translog.Serialized serialized = Translog.Serialized.create(
                headerBytes.slice(offset, headerBytes.length() - offset),
                null,
                new CRC32()
            );
            serialized.writeToTranslogBuffer(fullOperationOutput);

            BytesReference actualWithSize = fullOperationOutput.bytes();
            assertThat(actualWithSize.slice(4 + offset, actualWithSize.length() - offset - 4), equalTo(expectedWithoutSize));
        }
    }
}
